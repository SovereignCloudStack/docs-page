"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6735],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=l(n),u=r,h=m["".concat(c,".").concat(u)]||m[u]||p[u]||a;return n?o.createElement(h,i(i({ref:t},d),{},{components:n})):o.createElement(h,i({ref:t},d))}));function u(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},194:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const a={title:"Recommended naming for domains/groups/roles/project when onboarding new customers",type:"_Standard | Decision Record_",status:"Draft",track:"IAM"},i=void 0,s={unversionedId:"active/scs-0301-v1-naming-conventions",id:"active/scs-0301-v1-naming-conventions",title:"Recommended naming for domains/groups/roles/project when onboarding new customers",description:"\x3c!---",source:"@site/standards/active/scs-0301-v1-naming-conventions.md",sourceDirName:"active",slug:"/active/scs-0301-v1-naming-conventions",permalink:"/standards/active/scs-0301-v1-naming-conventions",draft:!1,tags:[],version:"current",frontMatter:{title:"Recommended naming for domains/groups/roles/project when onboarding new customers",type:"_Standard | Decision Record_",status:"Draft",track:"IAM"}},c={},l=[{value:"Introduction",id:"introduction",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Design Considerations",id:"design-considerations",level:2},{value:"Options considered",id:"options-considered",level:3},{value:"PS approach to naming",id:"ps-approach-to-naming",level:4},{value:"<em>Option 2</em>",id:"option-2",level:4},{value:"Open questions",id:"open-questions",level:2},{value:"Decision",id:"decision",level:2},{value:"Related Documents",id:"related-documents",level:2},{value:"Conformance Tests",id:"conformance-tests",level:2}],d={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"When CSPs try to enroll a new customer they encounter themselves in\na situation where they have to choose names for the openstack domain,\nproject and user."),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"Create a naming convention to use during the provisioning of the users and\ngroups through an openstack domain."),(0,r.kt)("h2",{id:"design-considerations"},"Design Considerations"),(0,r.kt)("p",null,"OPTIONAL"),(0,r.kt)("h3",{id:"options-considered"},"Options considered"),(0,r.kt)("h4",{id:"ps-approach-to-naming"},"PS approach to naming"),(0,r.kt)("p",null,"For naming the customers the suggestion from PS is the following:"),(0,r.kt)("p",null,"A prefix will be use to differenciate domain, project and user in\nthe openstack environment. The project name is also added as a sufix."),(0,r.kt)("p",null,"So the onboaring tool will create the following structure for a new\ncustomer onboarded in the system."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"domain: d<customer_id>\nproject: p<customer_id>-<project_name>\nuser: u<customer_id>-<user_name>\n")),(0,r.kt)("p",null,'For the customer also a domain admin group and a project admin group are\ncreated. Please note that, at the time of writing, PCO is not making any\nuse of OpenStack domains to isolate customers. So, for the scope of this\ndocument, the term "domain admin" is used in a conceptual way rather than\nreferring to the specific OpenStack implementation. For the scope of this\ndocument "domain admins" can do things like creating projects, creating\nusers and granting users access to some projects (within the domain of\ncourse). "Users" can create and view resources within the projects that\nthey have been granted access to by the "domain admin".\nThese groups use the prefix "gd" for domain group and "gp" for group project\nand are build like the following:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"domain admin group: gd<customer_id>-member\nproject admin group: gp<customer_id>-<project_name>-member\n")),(0,r.kt)("p",null,"For the creation of a domain a new domain admin group is created."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"openstack domain create d000001\nopenstack group create gd000001-member\n")),(0,r.kt)("p",null,"When a project is created a new admin group for that project is created."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"openstack project create p000001-scs_dev_project\nopenstack group create p000001-scs_dev_project-member\n")),(0,r.kt)("p",null,"After the creation of a project it is necessary to assign roles to the\nnew groups."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"openstack role add --group gd000001-member --project p000001-scs_dev_project $role\nopenstack role add --group gp000001-scs_dev_project-member --project p000001-scs_dev_project $role\n")),(0,r.kt)("p",null,'For the creation of regular non admin users, the accounts will be added\nto the "domain admin" group to give them access to all projects within\nthe domain.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"openstack user created u000001-user1\nopenstack group add user gd000001-member u000001-user1\n")),(0,r.kt)("p",null,'In the case of machine accounts, they are only added to the specific\n"project admin" groups.'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-commandline"},"openstack user created u000001-svc_user_project\nopenstack group add user gp000001-scs_dev_project-member u000001-svc_user_project\n")),(0,r.kt)("p",null,"In case of using federation, there are suggestions to the namings within Keycloak."),(0,r.kt)("p",null,'The realms in Keycloak for each customer would be the same as the customer. e.g. The Keycloak realm for "Customer A"\nwill be called "Customer A".'),(0,r.kt)("p",null,"There should be an OIDC client in each customer realm to allow the federation to the Proxy realm. Currently called OSISM\non the testbed."),(0,r.kt)("p",null,'On the proxy realm, it\'s needed to add this new customer realm as an idenity provider. During the creation of the identity\nprovider for "Customer A", the field "Alias" should be set to ',(0,r.kt)("inlineCode",{parentName:"p"},"<customer-id>"),'. This will make that the users federated from\nrealm "Customer A" to the proxy realm to be prefixed to avoid naming colisions, e.g. ',(0,r.kt)("inlineCode",{parentName:"p"},"d${ALIAS}-${CLAIM.preferred_username}"),"."),(0,r.kt)("p",null,"Also, on the identity federation there should be configured to store the ",(0,r.kt)("inlineCode",{parentName:"p"},"<customer-id>")," from that realm into the users. So it\ncan be send to Keystone mapping to use it as ",(0,r.kt)("inlineCode",{parentName:"p"},"gd<customer-id>-member")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"gp<customer-id>-<project_name>-member"),". There is\nalso the necessity of a mapper to send the ",(0,r.kt)("inlineCode",{parentName:"p"},"openstack-default-project"),"."),(0,r.kt)("p",null,"Add the aditional mappings for roles and groups as necessary to get the attributes from the customer realm into the OIDC\nuserinfo that is put into the OIDC to the proxy realm and from there to Keystone."),(0,r.kt)("h4",{id:"option-2"},(0,r.kt)("em",{parentName:"h4"},"Option 2")),(0,r.kt)("p",null,"Option 2 description"),(0,r.kt)("h2",{id:"open-questions"},"Open questions"),(0,r.kt)("p",null,"RECOMMENDED"),(0,r.kt)("h2",{id:"decision"},"Decision"),(0,r.kt)("p",null,"Decision"),(0,r.kt)("h2",{id:"related-documents"},"Related Documents"),(0,r.kt)("p",null,"Related Documents, OPTIONAL"),(0,r.kt)("h2",{id:"conformance-tests"},"Conformance Tests"),(0,r.kt)("p",null,"Conformance Tests, OPTIONAL"))}p.isMDXComponent=!0}}]);