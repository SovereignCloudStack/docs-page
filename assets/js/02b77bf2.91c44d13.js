"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8235],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=d(a),h=r,k=u["".concat(s,".").concat(h)]||u[h]||m[h]||i;return a?n.createElement(k,l(l({ref:t},p),{},{components:a})):n.createElement(k,l({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var d=2;d<i;d++)l[d]=a[d];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},7582:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const i={title:"SCS Flavor Naming Standard",type:"Standard",status:"Stable",stabilized_at:new Date("2023-06-14T00:00:00.000Z"),track:"IaaS",replaces:"scs-0100-v2-flavor-naming.md"},l=void 0,o={unversionedId:"active/scs-0100-v3-flavor-naming",id:"active/scs-0100-v3-flavor-naming",title:"SCS Flavor Naming Standard",description:"Introduction",source:"@site/standards/active/scs-0100-v3-flavor-naming.md",sourceDirName:"active",slug:"/active/scs-0100-v3-flavor-naming",permalink:"/standards/active/scs-0100-v3-flavor-naming",draft:!1,tags:[],version:"current",frontMatter:{title:"SCS Flavor Naming Standard",type:"Standard",status:"Stable",stabilized_at:"2023-06-14T00:00:00.000Z",track:"IaaS",replaces:"scs-0100-v2-flavor-naming.md"}},s={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Design Considerations",id:"design-considerations",level:2},{value:"Type of information included",id:"type-of-information-included",level:3},{value:"Complete Proposal for systematic flavor naming",id:"complete-proposal-for-systematic-flavor-naming",level:2},{value:"Proposal Details",id:"proposal-details",level:2},{value:"REQUIRED CPU Suffixes",id:"required-cpu-suffixes",level:3},{value:"Baseline",id:"baseline",level:4},{value:"Higher oversubscription",id:"higher-oversubscription",level:4},{value:"Insufficient microcode",id:"insufficient-microcode",level:4},{value:"Examples",id:"examples",level:4},{value:"REQUIRED Memory",id:"required-memory",level:3},{value:"Baseline",id:"baseline-1",level:4},{value:"No ECC",id:"no-ecc",level:4},{value:"Enabled Oversubscription",id:"enabled-oversubscription",level:4},{value:"Examples",id:"examples-1",level:4},{value:"OPTIONAL Disk sizes and types",id:"optional-disk-sizes-and-types",level:3},{value:"Baseline",id:"baseline-2",level:4},{value:"Multi-provisioned Disk",id:"multi-provisioned-disk",level:4},{value:"Examples",id:"examples-2",level:4},{value:"Standard SCS flavors",id:"standard-scs-flavors",level:2},{value:"Naming policy compliance",id:"naming-policy-compliance",level:2},{value:"Validation",id:"validation",level:2},{value:"Operational tooling",id:"operational-tooling",level:2},{value:"Extensions",id:"extensions",level:2},{value:"OPTIONAL Hypervisor",id:"optional-hypervisor",level:3},{value:"Examples",id:"examples-3",level:4},{value:"OPTIONAL Hardware virtualization / Nested virtualization",id:"optional-hardware-virtualization--nested-virtualization",level:3},{value:"Examples",id:"examples-4",level:4},{value:"OPTIONAL CPU Architecture Details",id:"optional-cpu-architecture-details",level:3},{value:"Generation and Vendor",id:"generation-and-vendor",level:4},{value:"Frequency Suffixes",id:"frequency-suffixes",level:4},{value:"Examples",id:"examples-5",level:4},{value:"OPTIONAL GPU support",id:"optional-gpu-support",level:3},{value:"OPTIONAL Infiniband",id:"optional-infiniband",level:3},{value:"Naming options advice",id:"naming-options-advice",level:3},{value:"Proposal Examples",id:"proposal-examples",level:2},{value:"Previous standard versions",id:"previous-standard-versions",level:2},{value:"Beyond SCS",id:"beyond-scs",level:2}],p={toc:d};function m(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"This is the standard v3.0 for SCS Release 5.\nNote that we intend to only extend it (so it's always backwards compatible),\nbut try to avoid changing in incompatible ways.\n(See at the end for the v1 to v2 transition where we have not met that\ngoal, but at least managed to have a 1:1 relationship between v1 and v2 names.)"),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"In OpenStack environments there is a need to define different flavors for instances.\nThe flavors are pre-defined by the operator, the customer can not change these.\nOpenStack providers thus typically offer a large selection of flavors."),(0,r.kt)("p",null,"While flavors can be discovered (",(0,r.kt)("inlineCode",{parentName:"p"},"openstack flavor list"),"), it is helpful for users (DevOps teams),\nto have"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A naming scheme that is used across all SCS flavors, so flavor names have the same meaning everywhere."),(0,r.kt)("li",{parentName:"ul"},"Have a guaranteed set of flavors available on all SCS clouds, so these do not need to be discovered.")),(0,r.kt)("p",null,"While not all details will be encoded in the name, the key features should be obvious:\nNumber of vCPUs, RAM, Root Disk.\nExtra features are important as well: There will be flavors with GPU support, fast disks for databases,\nmemory-heavy applications, and other useful aspects of an instance."),(0,r.kt)("p",null,"It may also be important to make the CPU generation clearly recognizable, as this is always a topic in\ndiscussions with customers."),(0,r.kt)("p",null,"Note that not all relevant properties of flavors can be discovered; creating a specification\nto address this is a separate but related effort to the name standardization.\nCommonly used infrastructure-as-code tools do not provide a way to use discoverability\nfeatures to express something like \"I want a flavor with 2 vCPUs, 8GiB of RAM, a local\n20GB SSD disk and Infiniband support but I don't care whether it's AMD or intel\" in a\nreasonable manner. Using flavor names to express this will thus continue to be useful\nand we don't expect the need for standardization of flavor names to go away until\nthe commonly used IaC tools work on a higher abstraction layer than they currently do."),(0,r.kt)("h2",{id:"design-considerations"},"Design Considerations"),(0,r.kt)("h3",{id:"type-of-information-included"},"Type of information included"),(0,r.kt)("p",null,"From discussions of our operators with their customers we learned that\nthe following characteristics are important in a flavor description:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Generation"),(0,r.kt)("td",{parentName:"tr",align:"left"},"CPU Generation")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Number of CPU"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Number of vCPUs - suffixed by L,V,T,C (see below)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Amount of RAM"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Amount of memory available for the VM")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"Performance Class"),(0,r.kt)("td",{parentName:"tr",align:"left"},"Ability to label high-performance CPUs, disks, network")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},"CPU Type"),(0,r.kt)("td",{parentName:"tr",align:"left"},"X86-intel, X86-amd, ARM, RISC-V, Generic")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},'"bms"'),(0,r.kt)("td",{parentName:"tr",align:"left"},"Bare Metal System (no virtualization/hypervisor)")))),(0,r.kt)("p",null,"This list is likely not comprehensive and will grow over time."),(0,r.kt)("p",null,"Rather than using random names ",(0,r.kt)("inlineCode",{parentName:"p"},"s5a.medium")," and assigning a discrete set of properties\nto them, we wanted to come up with a scheme that allows to systematically derive\nnames from properties and vice versa. The scheme allows for short names (by not\nencoding all details) as well as very detailed longer names."),(0,r.kt)("h2",{id:"complete-proposal-for-systematic-flavor-naming"},"Complete Proposal for systematic flavor naming"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Prefix"),(0,r.kt)("th",{parentName:"tr",align:null},"CPUs & Suffix"),(0,r.kt)("th",{parentName:"tr",align:null},"RAM","[GiB]"),(0,r.kt)("th",{parentName:"tr",align:null},"optional: Disk","[GB]","&type"),(0,r.kt)("th",{parentName:"tr",align:null},"opt: extensions"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"SCS-")),(0,r.kt)("td",{parentName:"tr",align:null},"N",(0,r.kt)("inlineCode",{parentName:"td"},"L/V/T/C"),"[",(0,r.kt)("inlineCode",{parentName:"td"},"i"),"]"),(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"-"),"N","[",(0,r.kt)("inlineCode",{parentName:"td"},"u"),"]","[",(0,r.kt)("inlineCode",{parentName:"td"},"o"),"]"),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"-"),"[","M",(0,r.kt)("inlineCode",{parentName:"td"},"x"),"]","N","[",(0,r.kt)("inlineCode",{parentName:"td"},"n/h/s/p"),"]","]"),(0,r.kt)("td",{parentName:"tr",align:null},"[",(0,r.kt)("inlineCode",{parentName:"td"},"_"),"EXT","]")))),(0,r.kt)("p",null,"Note that N and M are placeholders for numbers here.\nThe optional fields are denoted in brackets (and have opt: in the header.\nSee below for extensions."),(0,r.kt)("p",null,"Note that all letters are case-sensitive."),(0,r.kt)("p",null,"Typical flavor names look like ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-4V-16-50")," for a flavor with 4vCPUs (with limited\noversubscription), 16GiB RAM and a 50GB disk (of unspecified type)."),(0,r.kt)("h2",{id:"proposal-details"},"Proposal Details"),(0,r.kt)("h3",{id:"required-cpu-suffixes"},"[REQUIRED]"," CPU Suffixes"),(0,r.kt)("p",null,"Next to the number of vCPUs, these vCPUs need to be characterized to describe their nature."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Suffix"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"C"),(0,r.kt)("td",{parentName:"tr",align:null},"dedicated Core")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"T"),(0,r.kt)("td",{parentName:"tr",align:null},"dedicated Thread (SMT)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"V"),(0,r.kt)("td",{parentName:"tr",align:null},"vCPU (oversubscribed)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"L"),(0,r.kt)("td",{parentName:"tr",align:null},"vCPU (heavily oversubscribed)")))),(0,r.kt)("h4",{id:"baseline"},"Baseline"),(0,r.kt)("p",null,"Note that vCPU oversubscription for a ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," vCPU should be implemented such, that we\ncan guarantee ",(0,r.kt)("em",{parentName:"p"},"at least 20% of a core in >99% of the time"),"; this can be achieved by\nlimiting vCPU oversubscription to 5x per core (or 3x per thread when SMT/HT is enabled)\nor by more advanced workload management logic. Otherwise ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," (low performance) instead\nof ",(0,r.kt)("inlineCode",{parentName:"p"},"V")," must be used. The >99% is measured over a month (1% is 7.2h/month)."),(0,r.kt)("p",null,"Note that CPUs should use latest microcode to protect against CPU vulnerabilities (Spectre, Meltdown, L1TF, etc.).\nIn particular,"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"microcode must be updated within less than a month of a new release; for CVSS scores above 8,\nproviders should do it in less than a week."),(0,r.kt)("li",{parentName:"ul"},"all mitigations that are enabled by default in the Linux kernel and the KVM hypervisor\nshould be enabled,"),(0,r.kt)("li",{parentName:"ul"},"CPUs that are susceptible to L1TF (intel x86 pre Cascade Lake) should have hyperthreading\ndisabled OR (in the future) use core scheduling implementations that are deemed to be secure by the SCS security team.")),(0,r.kt)("p",null,"That is to say, except when the suffix ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," is used, the provider commits itself to implementing the appropriate mitigations\nif and when they become available, within the timeframes mentioned above."),(0,r.kt)("p",null,"If a provider does not want to commit to deploying available microcode fixes and upstream kernel/hypervisor updates within a month or\nif the provider wants to enable hyperthreading on compute hosts despite having CPUs susceptible to L1TF there\n(and no SCS-accepted core-scheduling mechanism is used for mitigation),\nthe flavors must be declared insecure with the ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," suffix (see below)."),(0,r.kt)("h4",{id:"higher-oversubscription"},"Higher oversubscription"),(0,r.kt)("p",null,"Must be indicated with a ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," vCPU type (low performance for > 5x/core or > 3x/thread oversubscription and\nthe lack of workload management that would prevent worst case performance <20% in more than 7.2h per month)."),(0,r.kt)("h4",{id:"insufficient-microcode"},"Insufficient microcode"),(0,r.kt)("p",null,"Not using these mitigations must be indicated by an additional ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," suffix for insecure\n(weak protection against CPU vulns through insufficient microcode, lack of disabled hyperthreading\non L1TF susceptible CPUs w/o effective core scheduling or disabled protections on the host/hypervisor)."),(0,r.kt)("h4",{id:"examples"},"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SCS-",(0,r.kt)("strong",{parentName:"li"},"2C"),"-4-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-",(0,r.kt)("strong",{parentName:"li"},"2T"),"-4-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-",(0,r.kt)("strong",{parentName:"li"},"2V"),"-4-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-",(0,r.kt)("strong",{parentName:"li"},"2L"),"-4-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-",(0,r.kt)("strong",{parentName:"li"},"2Li"),"-4-10n"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("del",{parentName:"li"},"SCS-",(0,r.kt)("strong",{parentName:"del"},"2"),"-","*","*","4-10n")," <- CPU suffix missing"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("del",{parentName:"li"},"SCS-",(0,r.kt)("strong",{parentName:"del"},"2iT"),"-4-10n")," <- This order is forbidden")),(0,r.kt)("h3",{id:"required-memory"},"[REQUIRED]"," Memory"),(0,r.kt)("h4",{id:"baseline-1"},"Baseline"),(0,r.kt)("p",null,"Cloud providers should use ECC memory.\nMemory oversubscription should not be used.\nIt is allowed to specify half GiBs (e.g. 3.5), though this is should not be done for larger memory sizes (>= 10GiB)."),(0,r.kt)("h4",{id:"no-ecc"},"No ECC"),(0,r.kt)("p",null,"If no ECC is used, the ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," suffix must indicate this."),(0,r.kt)("h4",{id:"enabled-oversubscription"},"Enabled Oversubscription"),(0,r.kt)("p",null,"If memory is oversubscribed, you must expose this with the ",(0,r.kt)("inlineCode",{parentName:"p"},"o")," suffix."),(0,r.kt)("h4",{id:"examples-1"},"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SCS-2C-",(0,r.kt)("strong",{parentName:"li"},"4"),"-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-",(0,r.kt)("strong",{parentName:"li"},"3.5"),"-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-",(0,r.kt)("strong",{parentName:"li"},"4u"),"-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-",(0,r.kt)("strong",{parentName:"li"},"4o"),"-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-",(0,r.kt)("strong",{parentName:"li"},"4uo"),"-10n"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("del",{parentName:"li"},"SCS-2C-",(0,r.kt)("strong",{parentName:"del"},"4ou"),"-10n")," <- This order is forbidden")),(0,r.kt)("h3",{id:"optional-disk-sizes-and-types"},"[OPTIONAL]"," Disk sizes and types"),(0,r.kt)("p",null,"Disk sizes (in GB) should use sizes 5, 10, 20, 50, 100, 200, 500, 1000."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Disk type"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"n"),(0,r.kt)("td",{parentName:"tr",align:null},"Network shared storage (ceph/cinder)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"h"),(0,r.kt)("td",{parentName:"tr",align:null},"Local disk (HDD: SATA/SAS class)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"s"),(0,r.kt)("td",{parentName:"tr",align:null},"Local SSD disk")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"p"),(0,r.kt)("td",{parentName:"tr",align:null},"Local high-perf NVMe")))),(0,r.kt)("h4",{id:"baseline-2"},"Baseline"),(0,r.kt)("p",null,"Note that disk type might be omitted \u2014 the user then can not take any assumptions\non what storage is provided for the root disk (that the image gets provisioned to)."),(0,r.kt)("p",null,"It does make sense for ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," to be requested explicitly to allow for smooth live migration.\n",(0,r.kt)("inlineCode",{parentName:"p"},"h")," typically provides latency advantages vs ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," (but not necessarily bandwidth and\nalso is more likely to fail), ",(0,r.kt)("inlineCode",{parentName:"p"},"s")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"p")," are for applications that need low\nlatency (high IOPS) and bandwidth disk I/O. ",(0,r.kt)("inlineCode",{parentName:"p"},"n")," storage is expected to survive\nsingle-disk and single-node failure."),(0,r.kt)("p",null,"For specific requirements on the SSD and NVMe disks regarding IOPS and\npower-loss protection, refer to Decision Record ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SovereignCloudStack/standards/blob/main/Standards/scs-0110-v1-ssd-flavors.md"},"scs-0110-ssd-flavors"),"."),(0,r.kt)("p",null,"If the disk size is left out, the cloud is expected to allocate a disk (network or local)\nthat is large enough to fit the root file system (",(0,r.kt)("inlineCode",{parentName:"p"},"min_disk")," in image). This automatic\nallocation is indicated with ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," without a disk size.\nIf the ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," is left out completely, the user must create a boot volume manually and\ntell the instance to boot from it or use the\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.openstack.org/api-ref/compute/?expanded=create-server-detail#create-server"},(0,r.kt)("inlineCode",{parentName:"a"},"block_device_mapping_v2")),"\nmechanism explicitly to create the boot volume from an image."),(0,r.kt)("h4",{id:"multi-provisioned-disk"},"Multi-provisioned Disk"),(0,r.kt)("p",null,"The disk size can be prefixed with ",(0,r.kt)("inlineCode",{parentName:"p"},"Mx prefix"),", where M is an integer specifying that the disk\nis provisioned M times. Multiple disks provided this way should be independent storage media,\nso users can expect some level of parallelism and independence."),(0,r.kt)("h4",{id:"examples-2"},"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"10n")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"10s")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"10s"),"_","bms_z3"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"3x10s")," <- Cloud creates three 10GB SSDs"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"3x10s"),"_","bms_z3"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"10")," <- Cloud decides disk type"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"10"),"_","bms_z3"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"n")," <- Cloud decides disk size (min_disk from image or larger)"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"li"},"n"),"_","bms_3"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4- <- Cloud decides disk type and size"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-","_","bms_z3"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-","_","bms_z3h_GNa-64_ib"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-","_","ib"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4 <- You need to specify a boot volume yourself (boot from volume, or use ",(0,r.kt)("inlineCode",{parentName:"li"},"block_device_mapping_v2"),")"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4_bms_z3"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-3x10 <- Cloud decides type and creates three 10GB volumes"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("del",{parentName:"li"},"SCS-2C-4-",(0,r.kt)("strong",{parentName:"del"},"1.5n"))," <- You must not specify disk sizes which are not in full GiBs")),(0,r.kt)("h2",{id:"standard-scs-flavors"},"Standard SCS flavors"),(0,r.kt)("p",null,"These are flavors that must exist on standard SCS clouds (x86-64)."),(0,r.kt)("p",null,"We recommend disk sizes to be 5, 10, 20, 50, 100, 200, 500, 1000GB, 2000GB.\nWe expect the most used vCPU:Mem","[GiB]"," ratio to be 1:4."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"vCPU:RAM ratio"),(0,r.kt)("th",{parentName:"tr",align:null},"Mandatory Flavors"),(0,r.kt)("th",{parentName:"tr",align:null},"Recommended Flavors"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1:4"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-4"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-4-10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2:8"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2V-8"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2V-8-20")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4:16"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4V-16, SCS-4V-16-100s"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4V-16-50")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8:32"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-8V-32"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-8V-32-100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1:2"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-2"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-2-5")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2:4"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2V-4, SCS-2V-4-20s"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2V-4-10")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4:8"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4V-8"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4V-8-20")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8:16"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-8V-16"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-8V-16-50")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16:32"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-16V-32"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-16V-32-100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1:8"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-8"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-8-20")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2:16"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2V-16"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2V-16-50")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4:32"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4V-32"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4V-32-100")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1:1"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1L-1"),(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1L-1-5")))),(0,r.kt)("p",null,"Note that all vCPUs of SCS standard flavors are oversubscribed \u2014 the smallest ",(0,r.kt)("inlineCode",{parentName:"p"},"1L-1"),"\nflavor allows for heavy oversubscription (note the ",(0,r.kt)("inlineCode",{parentName:"p"},"L"),"), and thus can be offered very\ncheaply \u2014 imagine jump hosts ..."),(0,r.kt)("p",null,"The design allows for small clouds (with CPUs with 16 Threads, 64GiB RAM\ncompute hosts) to offer all flavors."),(0,r.kt)("p",null,"Note that the flavors with fixed size root disks have all moved to Recommended\nin version 3 of the standard. This means that they are not a certification requirement any longer,\nbut we still recommend implementing these for backwards compatibility reasons.\nDisks types are not specified (and expected to be n or h typically)."),(0,r.kt)("p",null,"However, two flavors with SSD+ root disks have been added in v3, as defined in\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SovereignCloudStack/standards/blob/main/Standards/scs-0110-v1-ssd-flavors.md"},"scs-0110-v1-ssd-flavors.md")),(0,r.kt)("p",null,"Note: Compared to previous drafts, we have heavily reduced the variations\non disk sizes \u2014 this reflects that for the standard networked cinder\ndisks, you can pass ",(0,r.kt)("inlineCode",{parentName:"p"},"block_device_mapping_v2")," on server (VM) creation to\nallocate a boot disk of any size you desire. We have scaled the few\nrecommended disk sizes with the amount of RAM. For each flavor there is\nalso one ",(0,r.kt)("em",{parentName:"p"},"without")," a pre-attached disk \u2014 these are meant to be used\nto boot from a volume (either created beforehand or allocated on-the-fly\nwith ",(0,r.kt)("inlineCode",{parentName:"p"},"block_device_mapping_v2"),", e.g.\n",(0,r.kt)("inlineCode",{parentName:"p"},"openstack server create --flavor SCS-1V:2 --block-device-mapping sda=IMGUUID:image:12:true"),"\nto create a bootable 12G cinder volume from image ",(0,r.kt)("inlineCode",{parentName:"p"},"IMGUUID")," that gets tied to the VM\ninstance life cycle.)"),(0,r.kt)("h2",{id:"naming-policy-compliance"},"Naming policy compliance"),(0,r.kt)("p",null,"You are allowed to understate your performance; you may implement a SCS-1V-1-5 flavor with\na flavor that actually implements SCS-1T-1-5n (i.e. you dedicate a dedicated hyperthread instead\nof higher oversubscription) or even SCS-1C-1.5-8s (1 dedicated core, 50% more RAM and a 8GiB SSD).\nOr you may offer the (v3 mandatory) ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-2V-4-20s")," with a ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-2V-4-20p")," (using a local NVMe\ninstead of an SSD)."),(0,r.kt)("p",null,"Flavor names indicating certain capabilities must ",(0,r.kt)("em",{parentName:"p"},"at least")," provide these, otherwise they\nare in violation of the SCS specification and prevent SCS compliance."),(0,r.kt)("p",null,"We expect all cloud providers to offer the short, less specific flavor names (such as SCS-8V-32-100).\nLarger providers that offer more details (using the extension below) are expected to still also\noffer the short variants for usability and easier portability, even beyond the mandated flavors."),(0,r.kt)("p",null,"You must be very careful to expose low vCPU guarantees (",(0,r.kt)("inlineCode",{parentName:"p"},"L")," instead of ",(0,r.kt)("inlineCode",{parentName:"p"},"V"),"), insecure\nhyperthreading/microcode ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),", non-ECC-RAM ",(0,r.kt)("inlineCode",{parentName:"p"},"u"),", memory oversubscription ",(0,r.kt)("inlineCode",{parentName:"p"},"o"),". Note that omitting these qualifiers\nis ",(0,r.kt)("em",{parentName:"p"},"overstating")," your security, reliability or performance properties and may be reason for\nclients to feel betrayed or claim damages. This would prevent SCS compliance and certification;\nin extreme cases, the SCS project might be forced to work with public statements."),(0,r.kt)("p",null,"You may offer additional ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-")," flavors, following the naming scheme and rules outlined here."),(0,r.kt)("p",null,"You may offer additional flavors, not following above scheme and not starting with ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-")),(0,r.kt)("p",null,"You must not offer flavors with the ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-")," prefix which do not follow this naming scheme."),(0,r.kt)("p",null,"You must not extend the SCS naming scheme with your own extensions; you are encouraged however\nto suggest extensions that we can discuss and add to the official scheme."),(0,r.kt)("h2",{id:"validation"},"Validation"),(0,r.kt)("p",null,"There is a script in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SovereignCloudStack/standards/blob/main/Tests/iaas/flavor-naming/flavor-name-check.py"},(0,r.kt)("inlineCode",{parentName:"a"},"flavor-name-check.py")),"\nwhich can be used to decode, validate and construct flavor names.\n",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SovereignCloudStack/standards/blob/main/Tests/iaas/flavor-naming/flavor-name-describe.py"},(0,r.kt)("inlineCode",{parentName:"a"},"flavor-name-describe.py"))," outputs a human-readable decoding of the SCS flavor names.\nThese scripts must stay in sync with the specification text."),(0,r.kt)("p",null,"Ensure you have your OpenStack tooling (",(0,r.kt)("inlineCode",{parentName:"p"},"python3-openstackclient"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"OS_CLOUD"),") setup and call\n",(0,r.kt)("inlineCode",{parentName:"p"},"tools/flavor-name-check.py -c $(openstack flavor list -f value -c Name)")," to get a report\non the flavor list compliance of the cloud environment."),(0,r.kt)("p",null,"The script ",(0,r.kt)("inlineCode",{parentName:"p"},"flavor-names-openstack.py")," talks to the OpenStack API of the\ncloud specified by the ",(0,r.kt)("inlineCode",{parentName:"p"},"OS_CLOUD")," environment and queries properties and checks\nthe names for standards compliance and completeness w.r.t. the mandatory\nflavor list. It goes beyond the above example in checking that the discoverable\nfeatures of flavors (vCPUs, RAM, Disk) match what the flavor names claim.\nThis is used for SCS-compatible compliance testing."),(0,r.kt)("h2",{id:"operational-tooling"},"Operational tooling"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/osism/openstack-flavor-manager"},"openstack-flavor-manager")," is able to\ncreate all standard, mandatory SCS flavors for you. It takes input that can be generated by\n",(0,r.kt)("inlineCode",{parentName:"p"},"flavor-manager-input.py"),"."),(0,r.kt)("h2",{id:"extensions"},"Extensions"),(0,r.kt)("p",null,"Extensions provide a possibility for providers that offer a very differentiated set\nof flavors to indicate hypervisors, support for hardware/nested virtualization,\nCPU types and generations, high-frequency models, GPU support and GPU types as\nwell as Infiniband support. (More extensions may be appended in the future.)"),(0,r.kt)("p",null,"Using the systematic naming approach ensures that two providers that offer flavors\nwith the same specific features will use the same name for them, thus simplifying\nlife for their customers when consuming these flavors."),(0,r.kt)("p",null,"Note that there is no need to indicate all details and extra features this way.\nFlavors may always perform better or have more features than indicated in a name.\nUnderperformance (CPU suffixes ",(0,r.kt)("inlineCode",{parentName:"p"},"L")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"i")," or memory suffixes ",(0,r.kt)("inlineCode",{parentName:"p"},"o")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"u"),") on the other\nhand MUST be indicated in the name; this happens rarely in practice."),(0,r.kt)("p",null,"For smaller providers, the ability to e.g. differentiate between an AMD Milan and an intel\nIceLake and exposed the slightly different feature set to customers and have slightly\ndifferent price points is often not worth the extra effort. This is because having\nthis extra differentiation causes fragmentation of the machines (host aggregates)\nthat can offer these flavors, thus resulting in a lower utilization (as the capacity\nmanagement will need to have a certain amount of headroom per machine pool to avoid\nrunning out of capacity)."),(0,r.kt)("p",null,"Note that it is possible for providers to register both the generic short names and the\nlonger, more detailed names and allow them to use the same set of machines (host aggregates).\nNote that machines (hypervisors) can be part of more than one host aggregate."),(0,r.kt)("p",null,"The extensions have the format:"),(0,r.kt)("p",null,"[",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"hyp","]","[",(0,r.kt)("inlineCode",{parentName:"p"},"_hwv"),"]","[",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"[","arch","[","N","]","[",(0,r.kt)("inlineCode",{parentName:"p"},"h"),"]","[",(0,r.kt)("inlineCode",{parentName:"p"},"_"),"[",(0,r.kt)("inlineCode",{parentName:"p"},"G/g"),"]","X","[","N","]","[",(0,r.kt)("inlineCode",{parentName:"p"},"-"),"M","[",(0,r.kt)("inlineCode",{parentName:"p"},"h"),"]","]","]","[",(0,r.kt)("inlineCode",{parentName:"p"},"_ib"),"]"),(0,r.kt)("p",null,"Remember that letters are case-sensitive.\nIn case you wonder: Feature indicators are capitalized, modifiers are lower case.\n(An exception is the uppercase ",(0,r.kt)("inlineCode",{parentName:"p"},"_G")," for a pass-through GPU vs. lowercase ",(0,r.kt)("inlineCode",{parentName:"p"},"_g")," for vGPU.)"),(0,r.kt)("h3",{id:"optional-hypervisor"},"[OPTIONAL]"," Hypervisor"),(0,r.kt)("p",null,"The ",(0,r.kt)("em",{parentName:"p"},"default Hypervisor")," is assumed to be ",(0,r.kt)("inlineCode",{parentName:"p"},"KVM"),". Clouds, that offer different hypervisors\nor Bare Metal Systems should indicate the Hypervisor according to the following table:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"hyp"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"kvm"),(0,r.kt)("td",{parentName:"tr",align:null},"KVM")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"xen"),(0,r.kt)("td",{parentName:"tr",align:null},"Xen")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"vmw"),(0,r.kt)("td",{parentName:"tr",align:null},"VMware")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hyv"),(0,r.kt)("td",{parentName:"tr",align:null},"Hyper-V")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"bms"),(0,r.kt)("td",{parentName:"tr",align:null},"Bare Metal System")))),(0,r.kt)("h4",{id:"examples-3"},"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n","_",(0,r.kt)("strong",{parentName:"li"},"bms")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n","_",(0,r.kt)("strong",{parentName:"li"},"bms"),"_","z3h")),(0,r.kt)("h3",{id:"optional-hardware-virtualization--nested-virtualization"},"[OPTIONAL]"," Hardware virtualization / Nested virtualization"),(0,r.kt)("p",null,"If the instances that are created with this flavor support hardware-accelerated\nvirtualization, this can be reflected with the ",(0,r.kt)("inlineCode",{parentName:"p"},"_hwv")," flag (after the optional\nHypervisor flag). On x86, this means that in the instance, the CPU flag vmx (intel)\nor svm (AMD) is available. This will be the case on Bare Metal flavors on almost\nall non-ancient x86 CPUs or if your virtualization hypervisor is configured to\nsupport nested virtualization.\nFlavors without the ",(0,r.kt)("inlineCode",{parentName:"p"},"_hwv")," flag may or may not support hardware virtualization (as we\nrecommend enabling nesting, but don't require flavor names to reflect all\ncapabilities. Flavors may over-deliver ...)"),(0,r.kt)("h4",{id:"examples-4"},"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10 <- may or may not support HW virtualization in VMs"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10",(0,r.kt)("em",{parentName:"li"},"kvm"),(0,r.kt)("strong",{parentName:"li"},"hwv")," <- kvm with enabled nested virtualization"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10","_",(0,r.kt)("strong",{parentName:"li"},"hwv")," <- not recommended, but allowed"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10","_","bms","_",(0,r.kt)("strong",{parentName:"li"},"hwv")," <- better: bare metal with HW virt support (VMX on intel, SVM on AMD, ...)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("del",{parentName:"li"},"SCS-2C-4-10","_",(0,r.kt)("strong",{parentName:"del"},"hwv"),"_","xen")," <- illegal, wrong ordering")),(0,r.kt)("h3",{id:"optional-cpu-architecture-details"},"[OPTIONAL]"," CPU Architecture Details"),(0,r.kt)("p",null,"Arch details provide more details on the specific CPU:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Vendor"),(0,r.kt)("li",{parentName:"ul"},"Generation"),(0,r.kt)("li",{parentName:"ul"},"Frequency")),(0,r.kt)("h4",{id:"generation-and-vendor"},"Generation and Vendor"),(0,r.kt)("p",null,"The generations are vendor specific and can be left out.\nNot specifying arch means that we have a generic CPU (",(0,r.kt)("strong",{parentName:"p"},"x86-64"),").\nThe letters ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"z"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"a")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"r")," specify the vendors Intel,\nAMD (",(0,r.kt)("inlineCode",{parentName:"p"},"z")," like in Zen), ARM v8+, RISC-V."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Generation"),(0,r.kt)("th",{parentName:"tr",align:null},"i (Intel x86-64)"),(0,r.kt)("th",{parentName:"tr",align:null},"z (AMD x86-64)"),(0,r.kt)("th",{parentName:"tr",align:null},"\xa0a (AArch64)"),(0,r.kt)("th",{parentName:"tr",align:null},"r (RISC-V)"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"0"),(0,r.kt)("td",{parentName:"tr",align:null},"pre Skylake"),(0,r.kt)("td",{parentName:"tr",align:null},"pre Zen"),(0,r.kt)("td",{parentName:"tr",align:null},"pre Cortex A76"),(0,r.kt)("td",{parentName:"tr",align:null},"TBD")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"1"),(0,r.kt)("td",{parentName:"tr",align:null},"Skylake"),(0,r.kt)("td",{parentName:"tr",align:null},"Zen-1 (Naples)"),(0,r.kt)("td",{parentName:"tr",align:null},"A76/NeoN1 class"),(0,r.kt)("td",{parentName:"tr",align:null},"TBD")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"2"),(0,r.kt)("td",{parentName:"tr",align:null},"Cascade Lake"),(0,r.kt)("td",{parentName:"tr",align:null},"Zen-2 (Rome)"),(0,r.kt)("td",{parentName:"tr",align:null},"A78/x1/NeoV1 class"),(0,r.kt)("td",{parentName:"tr",align:null},"TBD")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"3"),(0,r.kt)("td",{parentName:"tr",align:null},"Ice Lake"),(0,r.kt)("td",{parentName:"tr",align:null},"Zen-3 (Milan)"),(0,r.kt)("td",{parentName:"tr",align:null},"A71x/NeoN2 (ARMv9)"),(0,r.kt)("td",{parentName:"tr",align:null},"TBD")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"4"),(0,r.kt)("td",{parentName:"tr",align:null},"Sapphire Rapids"),(0,r.kt)("td",{parentName:"tr",align:null},"Zen-4 (Genoa)"),(0,r.kt)("td",{parentName:"tr",align:null}),(0,r.kt)("td",{parentName:"tr",align:null},"TBD")))),(0,r.kt)("p",null,"It is recommended to leave out the ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),' when specifying the old generation; this will\nhelp the parser tool, which assumes 0 for an unspecified value and does leave it\nout when generating the name for comparison. In other words: 0 has a meaning of\n"rather old or unspecified".'),(0,r.kt)("h4",{id:"frequency-suffixes"},"Frequency Suffixes"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Suffix"),(0,r.kt)("th",{parentName:"tr",align:null},"Meaning"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"h"),(0,r.kt)("td",{parentName:"tr",align:null},">2.75GHz all-core")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hh"),(0,r.kt)("td",{parentName:"tr",align:null},">3.25GHz all-core")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"hhh"),(0,r.kt)("td",{parentName:"tr",align:null},">3.75GHz all-core")))),(0,r.kt)("h4",{id:"examples-5"},"Examples"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n"),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n","_",(0,r.kt)("strong",{parentName:"li"},"z")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n","_",(0,r.kt)("strong",{parentName:"li"},"z3")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n","_",(0,r.kt)("strong",{parentName:"li"},"z3h")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n","_",(0,r.kt)("strong",{parentName:"li"},"z3hh")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n",(0,r.kt)("em",{parentName:"li"},"bms"),(0,r.kt)("strong",{parentName:"li"},"z")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n",(0,r.kt)("em",{parentName:"li"},"bms"),(0,r.kt)("strong",{parentName:"li"},"z3")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n",(0,r.kt)("em",{parentName:"li"},"bms"),(0,r.kt)("strong",{parentName:"li"},"z3")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n",(0,r.kt)("em",{parentName:"li"},"bms"),(0,r.kt)("strong",{parentName:"li"},"z3h")),(0,r.kt)("li",{parentName:"ul"},"SCS-2C-4-10n",(0,r.kt)("em",{parentName:"li"},"bms"),(0,r.kt)("strong",{parentName:"li"},"z3hh")," <- Bare Metal, Intel Ice Lake with > 3.25GHz all core freq")),(0,r.kt)("h3",{id:"optional-gpu-support"},"[OPTIONAL]"," GPU support"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"_G"),"X","[","N","]","[",(0,r.kt)("inlineCode",{parentName:"p"},"-"),"M","[",(0,r.kt)("inlineCode",{parentName:"p"},"h"),"]","]"," indicates a Pass-Through GPU from vendor X of gen N with M compute units / SMs / EUs exposed.\n",(0,r.kt)("inlineCode",{parentName:"p"},"_g"),"X","[","N","]","[",(0,r.kt)("inlineCode",{parentName:"p"},"-"),"M","[",(0,r.kt)("inlineCode",{parentName:"p"},"h"),"]","]"," indicates a vGPU from vendor X of gen N with M compute units / SMs / EUs assigned."),(0,r.kt)("p",null,"Note that the vendor letter X is mandatory, generation and compute units are optional."),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"GPU"),(0,r.kt)("th",{parentName:"tr",align:null},"Vendor"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"N"),(0,r.kt)("td",{parentName:"tr",align:null},"nVidia")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"A"),(0,r.kt)("td",{parentName:"tr",align:null},"AMD")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"I"),(0,r.kt)("td",{parentName:"tr",align:null},"Intel")))),(0,r.kt)("p",null,"For nVidia, the generation N can be f=Fermi, k=Kepler, m=Maxwell, p=Pascal, v=Volta, t=turing, a=Ampere, l=Ada Lovelace, ...,\nfor AMD GCN-x=0.x, RDNA1=1, RDNA2=2, RDNA3=3, for intel Gen9=0.9, Xe(12.1)=1, ...\n(Note: This may need further work to properly reflect what's out there.)"),(0,r.kt)("p",null,"The optional ",(0,r.kt)("inlineCode",{parentName:"p"},"h")," suffix to the compute unit count indicates high-performance (e.g. high freq or special\nhigh bandwidth gfx memory such as HBM);\n",(0,r.kt)("inlineCode",{parentName:"p"},"h")," can be duplicated for even higher performance."),(0,r.kt)("h3",{id:"optional-infiniband"},"[OPTIONAL]"," Infiniband"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"_ib")," indicates Infiniband networking."),(0,r.kt)("p",null,"More extensions may be forthcoming and appended in a later revision of this spec."),(0,r.kt)("p",null,"Extensions need to be specified in the above mentioned order."),(0,r.kt)("h3",{id:"naming-options-advice"},"Naming options advice"),(0,r.kt)("p",null,"Note that we expect most clouds to prefer short flavor names,\nnot indicating CPU details or hypervisor types. See above list\nof standard flavors to get a feeling."),(0,r.kt)("p",null,"However, more successful providers will often need to differentiate their\nofferings in response to customer demand and allow customers to request\nflavors with specific detailed properties. The goal of this proposal is to avoid\nproviders to invent their own names and then refer customers to (currently\nincompletely standardized) ",(0,r.kt)("inlineCode",{parentName:"p"},"extra_specs"),"\nor worse a non-machine-readable service descriptions to find out the details."),(0,r.kt)("p",null,"So a cloud provider might well evolve from offering ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-8T-16-50")," to offering\n",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-8T-16-50n"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-8T-16-50n_i2")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-8T-16-50n_z2")," to specify that he\nis using network disks and offer a choice b/w intel Cascade-Lake and AMD Rome.\nWe would expect the cloud provider to still offer the generic flavor\n",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-8T-16-50")," and allow the scheduler (placement service) to pick both more\nspecific types (or just one if e.g. capacity management considerations suggest\nso). Providers in such cases should ensure that the price of a requested\nflavor does not depend on the scheduler decisions."),(0,r.kt)("p",null,"We are looking into the ",(0,r.kt)("a",{parentName:"p",href:"https://docs.openstack.org/image-guide/introduction.html#metadata-definition-metadefs-service"},"metadefs"),"\nmechanism and ",(0,r.kt)("a",{parentName:"p",href:"https://docs.openstack.org/api-guide/compute/extra_specs_and_properties.html"},"extra_specs"),"\nto allow customers to ask for specific flavor properties without the need to\nencode all these flavor details into the flavor name, so the optional pieces\nmay not be needed much. However, there must be a way to request flavor\nproperties without encoding the need into an image \u2014 the indirection via\nan image is considered broken by the SCS team."),(0,r.kt)("h2",{id:"proposal-examples"},"Proposal Examples"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Example"),(0,r.kt)("th",{parentName:"tr",align:null},"Decoding"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCS-2C-4-10n"),(0,r.kt)("td",{parentName:"tr",align:null},"2 dedicated cores (x86-64), 4GiB RAM, 10GB network disk")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCS-8Ti-32-50p_i1"),(0,r.kt)("td",{parentName:"tr",align:null},"8 dedicated hyperthreads (insecure), Skylake, 32GiB RAM, 50GB local NVMe")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1L-1u-5"),(0,r.kt)("td",{parentName:"tr",align:null},"1 vCPU (heavily oversubscribed), 1GiB Ram (no ECC), 5GB disk (unspecific)")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCS-16T-64-200s_GNa-64_ib"),(0,r.kt)("td",{parentName:"tr",align:null},"16 dedicated threads, 64GiB RAM, 200GB local SSD, Infiniband, 64 Passthrough nVidia Ampere SMs")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCS-4C-16-2x200p_a1"),(0,r.kt)("td",{parentName:"tr",align:null},"4 dedicated Arm64 cores (A76 class), 16GiB RAM, 2x200GB local NVMe drives")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"SCS-1V-0.5"),(0,r.kt)("td",{parentName:"tr",align:null},"1 vCPU, 0.5GiB RAM, no disk (boot from cinder volume)")))),(0,r.kt)("h2",{id:"previous-standard-versions"},"Previous standard versions"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/standards/active/scs-0100-v1-flavor-naming"},"Version 1 of the standard"),"\nused a slightly different naming syntax while the logic was exactly the same.\nWhat is a ",(0,r.kt)("inlineCode",{parentName:"p"},"-")," in v2 used to be a ",(0,r.kt)("inlineCode",{parentName:"p"},":"),"; ",(0,r.kt)("inlineCode",{parentName:"p"},"_")," used to be ",(0,r.kt)("inlineCode",{parentName:"p"},"-"),". The reason for\nthe change was certain Kubernetes tools using the flavor names as labels.\nLabels however are subject to stricter naming rules and in particular don't\nallow for a ",(0,r.kt)("inlineCode",{parentName:"p"},":"),". See ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/SovereignCloudStack/standards/issues/190"},"PR #190"),"\nfor a discussion."),(0,r.kt)("p",null,"Version 1 flavor names can be translated to v2 using the following transformation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"NAMEV2=$(echo \"$NAMEV1\" | sed -e 's/\\-/_/g' -e 's/:/-/g' -e 's/^SCS_/SCS-/')\n")),(0,r.kt)("p",null,"and the way back can be done with"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"NAMEV1=$(echo \"$NAMEV2\" | sed -e 's/\\-/:/g' -e 's/_/-/g' -e 's/^SCS:/SCS-/')\n")),(0,r.kt)("p",null,"For the time being, the validation tools still accept the old names with a warning\n(despite the unchanged ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-")," prefix) unless you pass option ",(0,r.kt)("inlineCode",{parentName:"p"},"-2")," to them. They will\nhowever not count v1 flavors towards fulfilling the needs against the corresponding\nv2 mandatory flavor list unless you pass the option ",(0,r.kt)("inlineCode",{parentName:"p"},"-1"),".\nIn other words: An IaaS infrastructure with the 26\nv1 mandatory flavors will produce 26 warnings (for using old flavors) and 26\nerrors (for missing the 26 mandatory v2 flavors) unless you pass ",(0,r.kt)("inlineCode",{parentName:"p"},"-1")," in which\ncase no errors and no warnings will be produced. Registering the 26 mandatory\nv2 flavor names in addition will result in passing the test with only 26\nwarnings \u2014 unless you specify ",(0,r.kt)("inlineCode",{parentName:"p"},"-2"),". If you do and want to pass you'll need\nto remove the old v1 names or rename them to no longer start with ",(0,r.kt)("inlineCode",{parentName:"p"},"SCS-"),"."),(0,r.kt)("h2",{id:"beyond-scs"},"Beyond SCS"),(0,r.kt)("p",null,"The Gaia-X provider working group which could have created a superseding standard\ndoes no longer exist."),(0,r.kt)("p",null,"However, we have been reaching out to the OpenStack Public Cloud SIG and the ALASCA\nmembers to seek further alignment."),(0,r.kt)("p",null,"Getting upstream OpenStack support for flavor aliases would provide more flexibility\nand ease migrations between providers, also providers that don't offer the SCS-\nflavors."),(0,r.kt)("p",null,"We also would like to see upstream ",(0,r.kt)("inlineCode",{parentName:"p"},"extra_specs")," standardizing the discoverability of some\nproperties exposed via the SCS names and work on IaC tooling (terraform ...)\nto make use of these when selecting a flavor."))}m.isMDXComponent=!0}}]);